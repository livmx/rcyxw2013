

关于模型
---------------
-   模型竟然还分前后端  不过从场景方面也是可以理解 不同场景 某个对象只有部分方法参与其中
    用例驱动编程（ivor 雅各布森 uml创始人之一很是倡导这种风格 ）中 提到泳道的概念 每个对象的某些方法 只出现在某个用例中
    这样对象模型看起来是横切的
                      <<class1 >>                           <<class2>>
                -----------------------                 -----------------------
                |                     |                |                     |
                                                       |                     |
                ..............................................................................................
                |                     |                |                     |
                                                       |                     |           泳道1
                |                     |
                ......................................................................................................
                |                     |                                                  泳道2
                |                     |
                ......................................................................................................

    另一种是DCI模型   Data Context Interchange  上下文中的方法注入到数据模型中  在特定上下文中对象具有不同的方法
    一般通过 Trait来实现！

    CQRS（命令请求责任分离架构）中一个模型（可以是AR）分离成两个 一个全是read性质的方法实现 另一个全是write性质的实现！


安装&升级
-------------
    安装与升级的实现 中间都有若干步骤，将这些步骤全部抽象出来 形成一个状态机 每个步骤都是课拆卸的 他们有共同的基类
    XxxStage  ...
    整个流程是多个页面交互的 信息跟踪使用SESSION来完成。  以后碰到跨多个页面才能完成的操作首先要想到session哦！


plugin
--------
都是搞正则过滤替换的！！！  是把整个渲染过后的文本中的特殊标记 进行正则处理！如果这样搞在yii中从来没用过的afterRender
和outputFilter是否就有用武之地了！